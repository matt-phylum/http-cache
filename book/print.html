<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js oranda-dark">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>http-cache</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">
        <link rel="stylesheet" href="oranda-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "oranda-dark" : "oranda-dark";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('orandamdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('orandamdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('orandamdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('oranda-dark')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="cache-modes.html"><strong aria-hidden="true">2.</strong> Cache Modes</a></li><li class="chapter-item expanded "><a href="development/development.html"><strong aria-hidden="true">3.</strong> Development</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="development/supporting-a-backend-cache-manager.html"><strong aria-hidden="true">3.1.</strong> Supporting a Backend Cache Manager</a></li><li class="chapter-item expanded "><a href="development/supporting-an-http-client.html"><strong aria-hidden="true">3.2.</strong> Supporting an HTTP Client</a></li></ol></li><li class="chapter-item expanded "><a href="clients/clients.html"><strong aria-hidden="true">4.</strong> Client Implementations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="clients/reqwest.html"><strong aria-hidden="true">4.1.</strong> reqwest</a></li><li class="chapter-item expanded "><a href="clients/surf.html"><strong aria-hidden="true">4.2.</strong> surf</a></li></ol></li><li class="chapter-item expanded "><a href="managers/managers.html"><strong aria-hidden="true">5.</strong> Backend Cache Manager Implementations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="managers/cacache.html"><strong aria-hidden="true">5.1.</strong> cacache</a></li><li class="chapter-item expanded "><a href="managers/moka.html"><strong aria-hidden="true">5.2.</strong> moka</a></li><li class="chapter-item expanded "><a href="managers/quick-cache.html"><strong aria-hidden="true">5.3.</strong> quick_cache</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="oranda-dark">Axo Dark</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="oranda-light">Axo Light</button></li>

                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">http-cache</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><code>http-cache</code> is a library that acts as a middleware for caching HTTP responses. It is intended to be used by other libraries to support multiple HTTP clients and backend cache managers, though it does come with two optional manager implementations out of the box. <code>http-cache</code> is built on top of <a href="https://github.com/kornelski/rusty-http-cache-semantics"><code>http-cache-semantics</code></a> which parses HTTP headers to correctly compute cacheability of responses.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cache-modes"><a class="header" href="#cache-modes">Cache Modes</a></h1>
<p>When constructing a new instance of <code>HttpCache</code>, you must specify a cache mode. The cache mode determines how the cache will behave in certain situations. These modes are similar to <a href="https://github.com/npm/make-fetch-happen#--optscache">make-fetch-happen cache options</a>. The available cache modes are:</p>
<ul>
<li>
<p><code>Default</code>: This mode will inspect the HTTP cache on the way to the network. If there is a fresh response it will be used. If there is a stale response a conditional request will be created, and a normal request otherwise. It then updates the HTTP cache with the response. If the revalidation request fails (for example, on a 500 or if you're offline), the stale response will be returned.</p>
</li>
<li>
<p><code>NoStore</code>: This mode will ignore the HTTP cache on the way to the network. It will always create a normal request, and will never cache the response.</p>
</li>
<li>
<p><code>Reload</code>: This mode will ignore the HTTP cache on the way to the network. It will always create a normal request, and will update the HTTP cache with the response.</p>
</li>
<li>
<p><code>NoCache</code>: This mode will create a conditional request if there is a response in the HTTP cache and a normal request otherwise. It then updates the HTTP cache with the response.</p>
</li>
<li>
<p><code>ForceCache</code>: This mode will inspect the HTTP cache on the way to the network. If there is a cached response it will be used regardless of freshness. If there is no cached response it will create a normal request, and will update the cache with the response.</p>
</li>
<li>
<p><code>OnlyIfCached</code>: This mode will inspect the HTTP cache on the way to the network. If there is a cached response it will be used regardless of freshness. If there is no cached response it will return a <code>504 Gateway Timeout</code> error.</p>
</li>
<li>
<p><code>IgnoreRules</code>: This mode will ignore the HTTP headers and always store a response given it was a 200 status code. It will also ignore the staleness when retrieving a response from the cache, so expiration of the cached response will need to be handled manually. If there was no cached response it will create a normal request, and will update the cache with the response.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development"><a class="header" href="#development">Development</a></h1>
<p><code>http-cache</code> is meant to be extended to support multiple HTTP clients and backend cache managers. A <a href="https://docs.rs/http-cache/latest/http_cache/trait.CacheManager.html"><code>CacheManager</code></a> trait has been provided to help ease support for new backend cache managers. Similarly, a <a href="https://docs.rs/http-cache/latest/http_cache/trait.Middleware.html"><code>Middleware</code></a> trait has been provided to help ease supporting new HTTP clients.</p>
<h2 id="supporting-a-backend-cache-manager"><a class="header" href="#supporting-a-backend-cache-manager"><a href="development/./supporting-a-backend-cache-manager.html">Supporting a Backend Cache Manager</a></a></h2>
<p>This section is intended for those looking to implement a custom backend cache manager, or understand how the <a href="https://docs.rs/http-cache/latest/http_cache/trait.CacheManager.html"><code>CacheManager</code></a> trait works.</p>
<h2 id="supporting-an-http-client"><a class="header" href="#supporting-an-http-client"><a href="development/./supporting-an-http-client.html">Supporting an HTTP Client</a></a></h2>
<p>This section is intended for those looking to implement a custom HTTP client, or understand how the <a href="https://docs.rs/http-cache/latest/http_cache/trait.Middleware.html"><code>Middleware</code></a> trait works.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supporting-a-backend-cache-manager-1"><a class="header" href="#supporting-a-backend-cache-manager-1">Supporting a Backend Cache Manager</a></h1>
<p>This section is intended for those looking to implement a custom backend cache manager, or understand how the <a href="https://docs.rs/http-cache/latest/http_cache/trait.CacheManager.html"><code>CacheManager</code></a> trait works.</p>
<h2 id="the-cachemanager-trait"><a class="header" href="#the-cachemanager-trait">The <code>CacheManager</code> trait</a></h2>
<p>The <a href="https://docs.rs/http-cache/latest/http_cache/trait.CacheManager.html"><code>CacheManager</code></a> trait is the main trait that needs to be implemented to support a new backend cache manager. It has three methods that it requires:</p>
<ul>
<li><code>get</code>: retrieve a cached response given the provided cache key</li>
<li><code>put</code>: store a response and related policy object in the cache associated with the provided cache key</li>
<li><code>delete</code>: remove a cached response from the cache associated with the provided cache key</li>
</ul>
<p>Because the methods are asynchronous, they currently require <a href="https://github.com/dtolnay/async-trait"><code>async_trait</code></a> to be derived. This may change in the future.</p>
<h3 id="the-get-method"><a class="header" href="#the-get-method">The <code>get</code> method</a></h3>
<p>The <code>get</code> method is used to retrieve a cached response given the provided cache key. It returns an <code>Result&lt;Option&lt;(HttpResponse, CachePolicy)&gt;, BoxError&gt;</code> where <code>HttpResponse</code> is the cached response and <a href="https://docs.rs/http-cache-semantics/latest/http_cache_semantics/struct.CachePolicy.html"><code>CachePolicy</code></a> is the associated cache policy object that provides us helpful metadata. If the cache key does not exist in the cache, <code>Ok(None)</code> is returned.</p>
<h3 id="the-put-method"><a class="header" href="#the-put-method">The <code>put</code> method</a></h3>
<p>The <code>put</code> method is used to store a response and related policy object in the cache associated with the provided cache key. It returns an <code>Result&lt;HttpResponse, BoxError&gt;</code> where <code>HttpResponse</code> is the passed response.</p>
<h3 id="the-delete-method"><a class="header" href="#the-delete-method">The <code>delete</code> method</a></h3>
<p>The <code>delete</code> method is used to remove a cached response from the cache associated with the provided cache key. It returns an <code>Result&lt;(), BoxError&gt;</code>.</p>
<h2 id="how-to-implement-a-custom-backend-cache-manager"><a class="header" href="#how-to-implement-a-custom-backend-cache-manager">How to implement a custom backend cache manager</a></h2>
<p>This guide will use the <a href="https://github.com/zkat/cacache-rs"><code>cacache</code></a> backend cache manager as an example. The full source can be found <a href="https://github.com/06chaynes/http-cache/blob/latest/http-cache/src/managers/cacache.rs">here</a>. There are several ways to accomplish this, so feel free to experiment!</p>
<h3 id="part-one-the-base-structs"><a class="header" href="#part-one-the-base-structs">Part One: The base structs</a></h3>
<p>The first step is to create a struct that will hold the cache manager's configuration or potentially the cache itself. This struct will implement the <code>CacheManager</code> trait. In this case, we'll call it <code>CACacheManager</code> and it will have a field to store the path for the cache directory.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
pub struct CACacheManager {
    /// Directory where the cache will be stored.
    pub path: PathBuf,
}
<span class="boring">}</span></code></pre></pre>
<p>Next we will create a struct to store the response and accompanying policy object. This struct will be used to store the response and policy object in the cache. We'll call it <code>Store</code>. This isn't strictly necessary, but I find this easier to work with.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Deserialize, Serialize)]
struct Store {
    response: HttpResponse,
    policy: CachePolicy,
}
<span class="boring">}</span></code></pre></pre>
<p>This struct will also derive <a href="https://github.com/serde-rs/serde">serde</a> Deserialize and Serialize to ease the serialization and deserialization with <a href="https://github.com/bincode-org/bincode">bincode</a>.</p>
<h3 id="part-two-implementing-the-cachemanager-trait"><a class="header" href="#part-two-implementing-the-cachemanager-trait">Part Two: Implementing the <code>CacheManager</code> trait</a></h3>
<p>Now that we have our base structs, we can implement the <code>CacheManager</code> trait for our <code>CACacheManager</code> struct. We'll start with the <code>get</code> method, but first we must make sure we derive async_trait.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait::async_trait]
impl CacheManager for CACacheManager {
    ...
<span class="boring">}</span></code></pre></pre>
<p>The <code>get</code> method accepts a <code>&amp;str</code> as the cache key and returns an <code>Result&lt;Option&lt;(HttpResponse, CachePolicy)&gt;, BoxError&gt;</code>. We will <a href="https://docs.rs/cacache/latest/cacache/fn.read.html"><code>read</code></a> function from <code>cacache</code> to lookup the cache key in the cache directory. If the cache key does not exist, we'll return <code>Ok(None)</code>. The object we will be serializing and deserializing is our <code>Store</code> struct.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
async fn get(
    &amp;self,
    cache_key: &amp;str,
) -&gt; Result&lt;Option&lt;(HttpResponse, CachePolicy)&gt;&gt; {
    let store: Store = match cacache::read(&amp;self.path, cache_key).await {
        Ok(d) =&gt; bincode::deserialize(&amp;d)?,
        Err(_e) =&gt; {
            return Ok(None);
        }
    };
    Ok(Some((store.response, store.policy)))
}
...
<span class="boring">}</span></code></pre></pre>
<p>Next we'll implement the <code>put</code> method. This method accepts a <code>String</code> as the cache key, a <code>HttpResponse</code> as the response, and a <code>CachePolicy</code> as the policy object. It returns an <code>Result&lt;HttpResponse, BoxError&gt;</code>. We will clone the response during our construction of the <code>Store</code> struct, then serialize the <code>Store</code> struct using <a href="https://docs.rs/bincode/latest/bincode/fn.serialize.html">serialize</a> and write it to the cache directory using <a href="https://docs.rs/cacache/latest/cacache/fn.write.html"><code>write</code></a> from <code>cacache</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
async fn put(
    &amp;self,
    cache_key: String,
    response: HttpResponse,
    policy: CachePolicy,
) -&gt; Result&lt;HttpResponse&gt; {
    let data = Store { response: response.clone(), policy };
    let bytes = bincode::serialize(&amp;data)?;
    cacache::write(&amp;self.path, cache_key, bytes).await?;
    Ok(response)
}
...
<span class="boring">}</span></code></pre></pre>
<p>Finally we'll implement the <code>delete</code> method. This method accepts a <code>&amp;str</code> as the cache key and returns an <code>Result&lt;(), BoxError&gt;</code>. We will use <a href="https://docs.rs/cacache/latest/cacache/fn.remove.html"><code>remove</code></a> from <code>cacache</code> to remove the object from the cache directory.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
async fn delete(&amp;self, cache_key: &amp;str) -&gt; Result&lt;()&gt; {
    Ok(cacache::remove(&amp;self.path, cache_key).await?)
}
...
<span class="boring">}</span></code></pre></pre>
<p>Our <code>CACacheManager</code> struct now meets the requirements of the <code>CacheManager</code> trait and is ready for use!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supporting-an-http-client-1"><a class="header" href="#supporting-an-http-client-1">Supporting an HTTP Client</a></h1>
<p>This section is intended for those who wish to add support for a new HTTP client to <code>http-cache</code>, or understand how the <a href="https://docs.rs/http-cache/latest/http_cache/trait.Middleware.html"><code>Middleware</code></a> trait works. If you are looking to use <code>http-cache</code> with an HTTP client that is already supported, please see the <a href="development/../clients/clients.html">Client Implementations</a> section.</p>
<h2 id="the-middleware-trait"><a class="header" href="#the-middleware-trait">The <code>Middleware</code> trait</a></h2>
<p>The <a href="https://docs.rs/http-cache/latest/http_cache/trait.Middleware.html"><code>Middleware</code></a> trait is the main trait that needs to be implemented to add support for a new HTTP client. It has nine methods that it requires:</p>
<ul>
<li><code>is_method_get_head</code>: returns <code>true</code> if the method of the request is <code>GET</code> or <code>HEAD</code>, <code>false</code> otherwise</li>
<li><code>policy</code>: returns a <a href="https://docs.rs/http-cache-semantics/latest/http_cache_semantics/struct.CachePolicy.html"><code>CachePolicy</code></a> with default options for the given <code>HttpResponse</code></li>
<li><code>policy_with_options</code>: returns a <a href="https://docs.rs/http-cache-semantics/latest/http_cache_semantics/struct.CachePolicy.html"><code>CachePolicy</code></a> with the provided <a href="https://docs.rs/http-cache-semantics/latest/http_cache_semantics/struct.CacheOptions.html"><code>CacheOptions</code></a> for the given <code>HttpResponse</code></li>
<li><code>update_headers</code>: updates the request headers with the provided <a href="https://docs.rs/http/latest/http/request/struct.Parts.html"><code>http::request::Parts</code></a></li>
<li><code>force_no_cache</code>: overrides the <code>Cache-Control</code> header to 'no-cache' derective</li>
<li><code>parts</code>: returns the <a href="https://docs.rs/http/latest/http/request/struct.Parts.html"><code>http::request::Parts</code></a> from the request</li>
<li><code>url</code>: returns the requested <a href="https://docs.rs/url/latest/url/struct.Url.html"><code>Url</code></a></li>
<li><code>method</code>: returns the method of the request as a <code>String</code></li>
<li><code>remote_fetch</code>: performs the request and returns the <code>HttpResponse</code></li>
</ul>
<p>Because the <code>remote_fetch</code> method is asynchronous, it currently requires <a href="https://github.com/dtolnay/async-trait"><code>async_trait</code></a> to be derived. This may change in the future.</p>
<h3 id="the-is_method_get_head-method"><a class="header" href="#the-is_method_get_head-method">The <code>is_method_get_head</code> method</a></h3>
<p>The <code>is_method_get_head</code> method is used to determine if the method of the request is <code>GET</code> or <code>HEAD</code>. It returns a <code>bool</code> where <code>true</code> indicates the method is <code>GET</code> or <code>HEAD</code>, and <code>false</code> if otherwise.</p>
<h3 id="the-policy-and-policy_with_options-methods"><a class="header" href="#the-policy-and-policy_with_options-methods">The <code>policy</code> and <code>policy_with_options</code> methods</a></h3>
<p>The <code>policy</code> method is used to generate the cache policy for the given <code>HttpResponse</code>. It returns a <a href="https://docs.rs/http-cache-semantics/latest/http_cache_semantics/struct.CachePolicy.html"><code>CachePolicy</code></a> with default options.</p>
<p>The <code>policy_with_options</code> method is used to generate the cache policy for the given <code>HttpResponse</code> with the provided <a href="https://docs.rs/http-cache-semantics/latest/http_cache_semantics/struct.CacheOptions.html"><code>CacheOptions</code></a>. It returns a <a href="https://docs.rs/http-cache-semantics/latest/http_cache_semantics/struct.CachePolicy.html"><code>CachePolicy</code></a>.</p>
<h3 id="the-update_headers-method"><a class="header" href="#the-update_headers-method">The <code>update_headers</code> method</a></h3>
<p>The <code>update_headers</code> method is used to update the request headers with the provided <a href="https://docs.rs/http/latest/http/request/struct.Parts.html"><code>http::request::Parts</code></a>.</p>
<h3 id="the-force_no_cache-method"><a class="header" href="#the-force_no_cache-method">The <code>force_no_cache</code> method</a></h3>
<p>The <code>force_no_cache</code> method is used to override the <code>Cache-Control</code> header to 'no-cache' derective. This is used to allow caching but force revalidation before resuse.</p>
<h3 id="the-parts-method"><a class="header" href="#the-parts-method">The <code>parts</code> method</a></h3>
<p>The <code>parts</code> method is used to return the <a href="https://docs.rs/http/latest/http/request/struct.Parts.html"><code>http::request::Parts</code></a> from the request which eases working with the <code>http_cache_semantics</code> crate.</p>
<h3 id="the-url-method"><a class="header" href="#the-url-method">The <code>url</code> method</a></h3>
<p>The <code>url</code> method is used to return the requested <a href="https://docs.rs/url/latest/url/struct.Url.html"><code>Url</code></a> in a standard format.</p>
<h3 id="the-method-method"><a class="header" href="#the-method-method">The <code>method</code> method</a></h3>
<p>The <code>method</code> method is used to return the HTTP method of the request as a <code>String</code> to standardize the format.</p>
<h3 id="the-remote_fetch-method"><a class="header" href="#the-remote_fetch-method">The <code>remote_fetch</code> method</a></h3>
<p>The <code>remote_fetch</code> method is used to perform the request and return the <code>HttpResponse</code>. This goal here is to abstract away the HTTP client implementation and return a more generic response type.</p>
<h2 id="how-to-implement-a-custom-http-client"><a class="header" href="#how-to-implement-a-custom-http-client">How to implement a custom HTTP client</a></h2>
<p>This guide will use the <a href="https://github.com/http-rs/surf"><code>surf</code></a> HTTP client as an example. The full source can be found <a href="https://github.com/06chaynes/http-cache/blob/latest/http-cache-surf/src/lib.rs">here</a>. There are several ways to accomplish this, so feel free to experiment!</p>
<h3 id="part-one-the-base-structs-1"><a class="header" href="#part-one-the-base-structs-1">Part One: The base structs</a></h3>
<p>First we will create a wrapper for the <a href="https://docs.rs/http-cache/latest/http_cache/struct.HttpCache.html"><code>HttpCache</code></a> struct. This is required because we cannot implement a trait for a type declared in another crate, see <a href="https://doc.rust-lang.org/error_codes/E0117.html">docs</a> for more info. We will call it <code>Cache</code> in this case.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct Cache&lt;T: CacheManager&gt;(pub HttpCache&lt;T&gt;);
<span class="boring">}</span></code></pre></pre>
<p>Next we will create a struct to store the request and anything else we will need for our <code>surf::Middleware</code> implementation (more on that later). This struct will also implement the http-cache <a href="https://docs.rs/http-cache/latest/http_cache/trait.Middleware.html"><code>Middleware</code></a> trait. We'll call it <code>SurfMiddleware</code> in this case.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub(crate) struct SurfMiddleware&lt;'a&gt; {
    pub req: Request,
    pub client: Client,
    pub next: Next&lt;'a&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="part-two-implementing-the-middleware-trait"><a class="header" href="#part-two-implementing-the-middleware-trait">Part Two: Implementing the <code>Middleware</code> trait</a></h3>
<p>Now that we have our base structs, we can implement the <code>Middleware</code> trait for our <code>SurfMiddleware</code> struct. We'll start with the <code>is_method_get_head</code> method, but first we must make sure we derive async_trait.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait::async_trait]
impl Middleware for SurfMiddleware&lt;'_&gt; {
    ...
<span class="boring">}</span></code></pre></pre>
<p>The <code>is_method_get_head</code> will check the request stored in our <code>SurfMiddleware</code> struct and return <code>true</code> if the method is <code>GET</code> or <code>HEAD</code>, <code>false</code> otherwise.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_method_get_head(&amp;self) -&gt; bool {
    self.req.method() == Method::Get || self.req.method() == Method::Head
}
<span class="boring">}</span></code></pre></pre>
<p>Next we'll implement the <code>policy</code> method. This method accepts a reference to the <code>HttpResponse</code> and returns a <a href="https://docs.rs/http-cache-semantics/latest/http_cache_semantics/struct.CachePolicy.html"><code>CachePolicy</code></a> with default options. We'll use the <a href="https://docs.rs/http-cache-semantics/latest/http_cache_semantics/struct.CachePolicy.html#method.new"><code>http_cache_semantics::CachePolicy::new</code></a> method to generate the policy.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn policy(&amp;self, response: &amp;HttpResponse) -&gt; Result&lt;CachePolicy&gt; {
    Ok(CachePolicy::new(&amp;self.parts()?, &amp;response.parts()?))
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>policy_with_options</code> method is similar to the <code>policy</code> method, but accepts a <a href="https://docs.rs/http-cache-semantics/latest/http_cache_semantics/struct.CacheOptions.html"><code>CacheOptions</code></a> struct to override the default options. We'll use the <a href="https://docs.rs/http-cache-semantics/latest/http_cache_semantics/struct.CachePolicy.html#method.new_options"><code>http_cache_semantics::CachePolicy::new_options</code></a> method to generate the policy.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn policy_with_options(
    &amp;self,
    response: &amp;HttpResponse,
    options: CacheOptions,
) -&gt; Result&lt;CachePolicy&gt; {
    Ok(CachePolicy::new_options(
        &amp;self.parts()?,
        &amp;response.parts()?,
        SystemTime::now(),
        options,
    ))
}
<span class="boring">}</span></code></pre></pre>
<p>Next we'll implement the <code>update_headers</code> method. This method accepts a reference to the <a href="https://docs.rs/http/latest/http/request/struct.Parts.html"><code>http::request::Parts</code></a> and updates the request headers. We will iterate over the part headers and attempt to convert the header value to a <a href="https://docs.rs/http/latest/http/header/struct.HeaderValue.html"><code>HeaderValue</code></a> and set the header on the request. If the conversion fails, we will return an error.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_headers(&amp;mut self, parts: &amp;Parts) -&gt; Result&lt;()&gt; {
    for header in parts.headers.iter() {
        let value = match HeaderValue::from_str(header.1.to_str()?) {
            Ok(v) =&gt; v,
            Err(_e) =&gt; return Err(Box::new(BadHeader)),
        };
        self.req.set_header(header.0.as_str(), value);
    }
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>force_no_cache</code> method is used to override the <code>Cache-Control</code> header in the request to 'no-cache' derective. This is used to allow caching but force revalidation before resuse.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn force_no_cache(&amp;mut self) -&gt; Result&lt;()&gt; {
    self.req.insert_header(CACHE_CONTROL.as_str(), &quot;no-cache&quot;);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>parts</code> method is used to return the <a href="https://docs.rs/http/latest/http/request/struct.Parts.html"><code>http::request::Parts</code></a> from the request which eases working with the <code>http_cache_semantics</code> crate.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parts(&amp;self) -&gt; Result&lt;Parts&gt; {
    let mut converted = request::Builder::new()
        .method(self.req.method().as_ref())
        .uri(self.req.url().as_str())
        .body(())?;
    {
        let headers = converted.headers_mut();
        for header in self.req.iter() {
            headers.insert(
                http::header::HeaderName::from_str(header.0.as_str())?,
                http::HeaderValue::from_str(header.1.as_str())?,
            );
        }
    }
    Ok(converted.into_parts().0)
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>url</code> method is used to return the requested <a href="https://docs.rs/url/latest/url/struct.Url.html"><code>Url</code></a> in a standard format.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn url(&amp;self) -&gt; Result&lt;Url&gt; {
    Ok(self.req.url().clone())
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>method</code> method is used to return the HTTP method of the request as a <code>String</code> to standardize the format.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn method(&amp;self) -&gt; Result&lt;String&gt; {
    Ok(self.req.method().as_ref().to_string())
}
<span class="boring">}</span></code></pre></pre>
<p>Finally, the <code>remote_fetch</code> method is used to perform the request and return the <code>HttpResponse</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn remote_fetch(&amp;mut self) -&gt; Result&lt;HttpResponse&gt; {
    let url = self.req.url().clone();
    let mut res =
        self.next.run(self.req.clone(), self.client.clone()).await?;
    let mut headers = HashMap::new();
    for header in res.iter() {
        headers.insert(
            header.0.as_str().to_owned(),
            header.1.as_str().to_owned(),
        );
    }
    let status = res.status().into();
    let version = res.version().unwrap_or(Version::Http1_1);
    let body: Vec&lt;u8&gt; = res.body_bytes().await?;
    Ok(HttpResponse {
        body,
        headers,
        status,
        url,
        version: version.try_into()?,
    })
}
<span class="boring">}</span></code></pre></pre>
<p>Our <code>SurfMiddleware</code> struct now meets the requirements of the <code>Middleware</code> trait. We can now implement the <a href="https://docs.rs/surf/latest/surf/middleware/trait.Middleware.html"><code>surf::middleware::Middleware</code></a> trait for our <code>Cache</code> struct.</p>
<h3 id="part-three-implementing-the-surfmiddlewaremiddleware-trait"><a class="header" href="#part-three-implementing-the-surfmiddlewaremiddleware-trait">Part Three: Implementing the <code>surf::middleware::Middleware</code> trait</a></h3>
<p>We have our <code>Cache</code> struct that wraps our <code>HttpCache</code> struct, but we need to implement the <a href="https://docs.rs/surf/latest/surf/middleware/trait.Middleware.html"><code>surf::middleware::Middleware</code></a> trait for it. This is required to use our <code>Cache</code> struct as a middleware with <code>surf</code>. This part may differ depending on the HTTP client you are supporting.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[surf::utils::async_trait]
impl&lt;T: CacheManager&gt; surf::middleware::Middleware for Cache&lt;T&gt; {
    async fn handle(
        &amp;self,
        req: Request,
        client: Client,
        next: Next&lt;'_&gt;,
    ) -&gt; std::result::Result&lt;surf::Response, http_types::Error&gt; {
        let middleware = SurfMiddleware { req, client, next };
        let res = self.0.run(middleware).await.map_err(to_http_types_error)?;
        let mut converted = Response::new(StatusCode::Ok);
        for header in &amp;res.headers {
            let val = HeaderValue::from_bytes(header.1.as_bytes().to_vec())?;
            converted.insert_header(header.0.as_str(), val);
        }
        converted.set_status(res.status.try_into()?);
        converted.set_version(Some(res.version.try_into()?));
        converted.set_body(res.body);
        Ok(surf::Response::from(converted))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>First we create a <a href="development/supporting-an-http-client.html#part-two-implementing-the-middleware-trait"><code>SurfMiddleware</code></a> struct with the provided <code>req</code>, <code>client</code>, and <code>next</code> arguments. Then we call the <code>run</code> method on our <code>HttpCache</code> struct with our <code>SurfMiddleware</code> struct as the argument. This will perform the request and return the <code>HttpResponse</code>. We then convert the <code>HttpResponse</code> to a <code>surf::Response</code> and return it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client-implementations"><a class="header" href="#client-implementations">Client Implementations</a></h1>
<p>The following client implementations are provided by this crate:</p>
<h2 id="reqwest"><a class="header" href="#reqwest"><a href="clients/./reqwest.html">reqwest</a></a></h2>
<p>The <a href="https://github.com/06chaynes/http-cache/tree/latest/http-cache-reqwest"><code>http-cache-reqwest</code></a> crate provides a <a href="https://docs.rs/http-cache/latest/http_cache/trait.Middleware.html"><code>Middleware</code></a> implementation for the <a href="https://github.com/seanmonstar/reqwest"><code>reqwest</code></a> HTTP client.</p>
<h2 id="surf"><a class="header" href="#surf"><a href="clients/./surf.html">surf</a></a></h2>
<p>The <a href="https://github.com/06chaynes/http-cache/tree/latest/http-cache-surf"><code>http-cache-surf</code></a> crate provides a <a href="https://docs.rs/http-cache/latest/http_cache/trait.Middleware.html"><code>Middleware</code></a> implementation for the <a href="https://github.com/http-rs/surf"><code>surf</code></a> HTTP client.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reqwest-1"><a class="header" href="#reqwest-1">reqwest</a></h1>
<p>The <a href="https://github.com/06chaynes/http-cache/tree/latest/http-cache-reqwest"><code>http-cache-reqwest</code></a> crate provides a <a href="https://docs.rs/http-cache/latest/http_cache/trait.Middleware.html"><code>Middleware</code></a> implementation for the <a href="https://github.com/seanmonstar/reqwest"><code>reqwest</code></a> HTTP client. It accomplishes this by utilizing <a href="https://github.com/TrueLayer/reqwest-middleware"><code>reqwest_middleware</code></a>.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<pre><code class="language-sh">cargo add http-cache-reqwest
</code></pre>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li><code>manager-cacache</code>: (default) Enables the <a href="https://docs.rs/http-cache/latest/http_cache/struct.CACacheManager.html"><code>CACacheManager</code></a> backend cache manager.</li>
<li><code>manager-moka</code>: Enables the <a href="https://docs.rs/http-cache/latest/http_cache/struct.MokaManager.html"><code>MokaManager</code></a> backend cache manager.</li>
</ul>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>In the following example we will construct our client using the builder provided by <a href="https://github.com/TrueLayer/reqwest-middleware"><code>reqwest_middleware</code></a> with our cache struct from <a href="https://github.com/06chaynes/http-cache/tree/latest/http-cache-reqwest"><code>http-cache-reqwest</code></a>. This example will use the default mode, default cacache manager, and default http cache options.</p>
<p>After constructing our client, we will make a request to the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching">MDN Caching Docs</a> which should result in an object stored in cache on disk.</p>
<pre><pre class="playground"><code class="language-rust">use reqwest::Client;
use reqwest_middleware::{ClientBuilder, Result};
use http_cache_reqwest::{Cache, CacheMode, CACacheManager, HttpCache, HttpCacheOptions};

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let client = ClientBuilder::new(Client::new())
        .with(Cache(HttpCache {
          mode: CacheMode::Default,
          manager: CACacheManager::default(),
          options: HttpCacheOptions::default(),
        }))
        .build();
    client
        .get(&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching&quot;)
        .send()
        .await?;
    Ok(())
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="surf-1"><a class="header" href="#surf-1">surf</a></h1>
<p>The <a href="https://github.com/06chaynes/http-cache/tree/latest/http-cache-surf"><code>http-cache-surf</code></a> crate provides a <a href="https://docs.rs/http-cache/latest/http_cache/trait.Middleware.html"><code>Middleware</code></a> implementation for the <a href="https://github.com/http-rs/surf"><code>surf</code></a> HTTP client.</p>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<pre><code class="language-sh">cargo add http-cache-surf
</code></pre>
<h2 id="features-1"><a class="header" href="#features-1">Features</a></h2>
<ul>
<li><code>manager-cacache</code>: (default) Enables the <a href="https://docs.rs/http-cache/latest/http_cache/struct.CACacheManager.html"><code>CACacheManager</code></a> backend cache manager.</li>
<li><code>manager-moka</code>: Enables the <a href="https://docs.rs/http-cache/latest/http_cache/struct.MokaManager.html"><code>MokaManager</code></a> backend cache manager.</li>
</ul>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>In the following example we will construct our client with our cache struct from <a href="https://github.com/06chaynes/http-cache/tree/latest/http-cache-surf"><code>http-cache-surf</code></a>. This example will use the default mode, default cacache manager, and default http cache options.</p>
<p>After constructing our client, we will make a request to the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching">MDN Caching Docs</a> which should result in an object stored in cache on disk.</p>
<pre><pre class="playground"><code class="language-rust">use http_cache_surf::{Cache, CacheMode, CACacheManager, HttpCache, HttpCacheOptions};

#[async_std::main]
async fn main() -&gt; surf::Result&lt;()&gt; {
    let req = surf::get(&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching&quot;);
    surf::client()
        .with(Cache(HttpCache {
          mode: CacheMode::Default,
          manager: CACacheManager::default(),
          options: HttpCacheOptions::default(),
        }))
        .send(req)
        .await?;
    Ok(())
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backend-cache-manager-implementations"><a class="header" href="#backend-cache-manager-implementations">Backend Cache Manager Implementations</a></h1>
<p>The following backend cache manager implementations are provided by this crate:</p>
<h2 id="cacache"><a class="header" href="#cacache"><a href="managers/./cacache.html">cacache</a></a></h2>
<p><a href="https://github.com/zkat/cacache-rs"><code>cacache</code></a> is a high-performance, concurrent, content-addressable disk cache, optimized for async APIs.</p>
<h2 id="moka"><a class="header" href="#moka"><a href="managers/./moka.html">moka</a></a></h2>
<p><a href="https://github.com/moka-rs/moka"><code>moka</code></a> is a fast, concurrent cache library inspired by the Caffeine library for Java.</p>
<h2 id="quick_cache"><a class="header" href="#quick_cache"><a href="managers/./quick_cache.html">quick_cache</a></a></h2>
<p><a href="https://github.com/arthurprs/quick-cache"><code>quick_cache</code></a> is a lightweight and high performance concurrent cache optimized for low cache overhead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cacache-1"><a class="header" href="#cacache-1">cacache</a></h1>
<p><a href="https://github.com/zkat/cacache-rs"><code>cacache</code></a> is a high-performance, concurrent, content-addressable disk cache, optimized for async APIs.</p>
<h2 id="getting-started-2"><a class="header" href="#getting-started-2">Getting Started</a></h2>
<p>The <code>cacache</code> backend cache manager is provided by the <code>http-cache</code> crate and is enabled by default. Both the <code>http-cache-reqwest</code> and <code>http-cache-surf</code> crates expose the types so no need to pull in the <code>http-cache</code> directly unless you need to implement your own client.</p>
<h3 id="reqwest-2"><a class="header" href="#reqwest-2">reqwest</a></h3>
<pre><code class="language-sh">cargo add http-cache-reqwest
</code></pre>
<h3 id="surf-2"><a class="header" href="#surf-2">surf</a></h3>
<pre><code class="language-sh">cargo add http-cache-surf
</code></pre>
<h2 id="working-with-the-manager-directly"><a class="header" href="#working-with-the-manager-directly">Working with the manager directly</a></h2>
<p>First construct your manager instance. This example will use the default cache directory.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let manager = CACacheManager::default();
<span class="boring">}</span></code></pre></pre>
<p>You can also specify the cache directory.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let manager = CACacheManager {
    path: &quot;./my-cache&quot;.into(),
};
<span class="boring">}</span></code></pre></pre>
<p>You can attempt to retrieve a record from the cache using the <code>get</code> method. This method accepts a <code>&amp;str</code> as the cache key and returns an <code>Result&lt;Option&lt;(HttpResponse, CachePolicy)&gt;, BoxError&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let response = manager.get(&quot;my-cache-key&quot;).await?;
<span class="boring">}</span></code></pre></pre>
<p>You can store a record in the cache using the <code>put</code> method. This method accepts a <code>String</code> as the cache key, a <code>HttpResponse</code> as the response, and a <code>CachePolicy</code> as the policy object. It returns an <code>Result&lt;HttpResponse, BoxError&gt;</code>. The below example constructs the response and policy manually, normally this would be handled by the middleware.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let url = Url::parse(&quot;http://example.com&quot;)?;
let response = HttpResponse {
    body: TEST_BODY.to_vec(),
    headers: Default::default(),
    status: 200,
    url: url.clone(),
    version: HttpVersion::Http11,
};
let req = http::Request::get(&quot;http://example.com&quot;).body(())?;
let res = http::Response::builder()
    .status(200)
    .body(TEST_BODY.to_vec())?;
let policy = CachePolicy::new(&amp;req, &amp;res);
let response = manager.put(&quot;my-cache-key&quot;.into(), response, policy).await?;
<span class="boring">}</span></code></pre></pre>
<p>You can remove a record from the cache using the <code>delete</code> method. This method accepts a <code>&amp;str</code> as the cache key and returns an <code>Result&lt;(), BoxError&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>manager.delete(&quot;my-cache-key&quot;).await?;
<span class="boring">}</span></code></pre></pre>
<p>You can also clear the entire cache using the <code>clear</code> method. This method accepts no arguments and returns an <code>Result&lt;(), BoxError&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>manager.clear().await?;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="moka-1"><a class="header" href="#moka-1">moka</a></h1>
<p><a href="https://github.com/moka-rs/moka"><code>moka</code></a> is a fast, concurrent cache library inspired by the Caffeine library for Java.</p>
<h2 id="getting-started-3"><a class="header" href="#getting-started-3">Getting Started</a></h2>
<p>The <code>moka</code> backend cache manager is provided by the <code>http-cache</code> crate but is not enabled by default. Both the <code>http-cache-reqwest</code> and <code>http-cache-surf</code> crates expose the types so no need to pull in the <code>http-cache</code> directly unless you need to implement your own client.</p>
<h3 id="reqwest-3"><a class="header" href="#reqwest-3">reqwest</a></h3>
<pre><code class="language-sh">cargo add http-cache-reqwest --no-default-features -F manager-moka
</code></pre>
<h3 id="surf-3"><a class="header" href="#surf-3">surf</a></h3>
<pre><code class="language-sh">cargo add http-cache-surf --no-default-features -F manager-moka
</code></pre>
<h2 id="working-with-the-manager-directly-1"><a class="header" href="#working-with-the-manager-directly-1">Working with the manager directly</a></h2>
<p>First construct your manager instance. This example will use the default cache configuration (42).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let manager = Arc::new(MokaManager::default());
<span class="boring">}</span></code></pre></pre>
<p>You can also specify other configuration options. This uses the <code>new</code> methods on both <code>MokaManager</code> and <code>moka::future::Cache</code> to construct a cache with a maximum capacity of 100 items.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let manager = Arc::new(MokaManager::new(moka::future::Cache::new(100)));
<span class="boring">}</span></code></pre></pre>
<p>You can attempt to retrieve a record from the cache using the <code>get</code> method. This method accepts a <code>&amp;str</code> as the cache key and returns an <code>Result&lt;Option&lt;(HttpResponse, CachePolicy)&gt;, BoxError&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let response = manager.get(&quot;my-cache-key&quot;).await?;
<span class="boring">}</span></code></pre></pre>
<p>You can store a record in the cache using the <code>put</code> method. This method accepts a <code>String</code> as the cache key, a <code>HttpResponse</code> as the response, and a <code>CachePolicy</code> as the policy object. It returns an <code>Result&lt;HttpResponse, BoxError&gt;</code>. The below example constructs the response and policy manually, normally this would be handled by the middleware.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let url = Url::parse(&quot;http://example.com&quot;)?;
let response = HttpResponse {
    body: TEST_BODY.to_vec(),
    headers: Default::default(),
    status: 200,
    url: url.clone(),
    version: HttpVersion::Http11,
};
let req = http::Request::get(&quot;http://example.com&quot;).body(())?;
let res = http::Response::builder()
    .status(200)
    .body(TEST_BODY.to_vec())?;
let policy = CachePolicy::new(&amp;req, &amp;res);
let response = manager.put(&quot;my-cache-key&quot;.into(), response, policy).await?;
<span class="boring">}</span></code></pre></pre>
<p>You can remove a record from the cache using the <code>delete</code> method. This method accepts a <code>&amp;str</code> as the cache key and returns an <code>Result&lt;(), BoxError&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>manager.delete(&quot;my-cache-key&quot;).await?;
<span class="boring">}</span></code></pre></pre>
<p>You can also clear the entire cache using the <code>clear</code> method. This method accepts no arguments and returns an <code>Result&lt;(), BoxError&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>manager.clear().await?;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick_cache-1"><a class="header" href="#quick_cache-1">quick_cache</a></h1>
<p><a href="https://github.com/arthurprs/quick-cache"><code>quick_cache</code></a> is a lightweight and high performance concurrent cache optimized for low cache overhead.</p>
<h2 id="getting-started-4"><a class="header" href="#getting-started-4">Getting Started</a></h2>
<p>The <code>quick_cache</code> backend cache manager is provided by the <a href="https://github.com/06chaynes/http-cache/tree/latest/http-cache-quickcache"><code>http-cache-quickcache</code></a> crate.</p>
<pre><code class="language-sh">cargo add http-cache-quickcache
</code></pre>
<h2 id="working-with-the-manager-directly-2"><a class="header" href="#working-with-the-manager-directly-2">Working with the manager directly</a></h2>
<p>First construct your manager instance. This example will use the default cache configuration (42).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let manager = Arc::new(QuickManager::default());
<span class="boring">}</span></code></pre></pre>
<p>You can also specify other configuration options. This uses the <code>new</code> methods on both <code>QuickManager</code> and <code>quick_cache::sync::Cache</code> to construct a cache with a maximum capacity of 100 items.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let manager = Arc::new(QuickManager::new(quick_cache::sync::Cache::new(100)));
<span class="boring">}</span></code></pre></pre>
<p>You can attempt to retrieve a record from the cache using the <code>get</code> method. This method accepts a <code>&amp;str</code> as the cache key and returns an <code>Result&lt;Option&lt;(HttpResponse, CachePolicy)&gt;, BoxError&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let response = manager.get(&quot;my-cache-key&quot;).await?;
<span class="boring">}</span></code></pre></pre>
<p>You can store a record in the cache using the <code>put</code> method. This method accepts a <code>String</code> as the cache key, a <code>HttpResponse</code> as the response, and a <code>CachePolicy</code> as the policy object. It returns an <code>Result&lt;HttpResponse, BoxError&gt;</code>. The below example constructs the response and policy manually, normally this would be handled by the middleware.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let url = Url::parse(&quot;http://example.com&quot;)?;
let response = HttpResponse {
    body: TEST_BODY.to_vec(),
    headers: Default::default(),
    status: 200,
    url: url.clone(),
    version: HttpVersion::Http11,
};
let req = http::Request::get(&quot;http://example.com&quot;).body(())?;
let res = http::Response::builder()
    .status(200)
    .body(TEST_BODY.to_vec())?;
let policy = CachePolicy::new(&amp;req, &amp;res);
let response = manager.put(&quot;my-cache-key&quot;.into(), response, policy).await?;
<span class="boring">}</span></code></pre></pre>
<p>You can remove a record from the cache using the <code>delete</code> method. This method accepts a <code>&amp;str</code> as the cache key and returns an <code>Result&lt;(), BoxError&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>manager.delete(&quot;my-cache-key&quot;).await?;
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
